diff --git a/src/main.cpp b/src/main.cpp
index ad68c4a..72de0d6 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -518,6 +518,42 @@ int64 CTransaction::GetMinFee(unsigned int nBlockSize, bool fAllowFree,
 
     unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);
     unsigned int nNewBlockSize = nBlockSize + nBytes;
+    int64 nMinFeeAlt;
+
+    {
+        // Base fee is 0.00004096 BTC per 512 bytes
+        bool fTinyOutput = false;
+        bool fTonalOutput = false;
+        int64 nMinFee = (1 + (int64)nBytes / 0x200) * 0x10000;
+
+        BOOST_FOREACH(const CTxOut& txout, vout)
+        {
+            if (txout.nValue < 0x100)
+            {
+                fTinyOutput = true;
+                break;
+            }
+            if (0 == txout.nValue % 0x10000)
+                fTonalOutput = true;
+        }
+
+        // Charge extra for ridiculously tiny outputs
+        if (fTinyOutput)
+            nMinFee *= 0x10;
+        else
+        // Waive the fee in a tonal-sized "free tranaction area" if at least one output is TBC (and under 512 bytes) ;)
+        if (fTonalOutput && nNewBlockSize < 0x8000 && nBytes < 0x200)
+            nMinFee = 0;
+        else
+        if (fAllowFree)
+        {
+            // Give a discount to the first so many tx
+            nMinFee /= 0x10;
+        }
+
+        nMinFeeAlt = nMinFee;
+    }
+
     int64 nMinFee = (1 + (int64)nBytes / 1000) * nBaseFee;
 
     if (fAllowFree)
@@ -551,6 +587,8 @@ int64 CTransaction::GetMinFee(unsigned int nBlockSize, bool fAllowFree,
         }
     }
 
+    nMinFee = std::min(nMinFee, nMinFeeAlt);
+
     // Raise the price as the block approaches full
     if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)
     {
@@ -669,6 +707,9 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
         if (!fFromMe || pwalletMain->IsMine(tx))
         {
 
+        if (!fFromMe)
+        {
+
         // Don't accept it if it can't get into a block
         int64 txMinFee = tx.GetMinFee(1000, true, GMF_RELAY);
         if (nFees < txMinFee)
@@ -703,6 +744,8 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
 
         }
 
+        }
+
         // Check against previous transactions
         // This is done last to help prevent CPU exhaustion denial-of-service attacks.
         if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))
diff --git a/src/net.cpp b/src/net.cpp
index 3fab046..1cda8df 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -1171,6 +1171,7 @@ void MapPort()
 // The first name is used as information source for addrman.
 // The second name should resolve to a list of seed addresses.
 static const char *strDNSSeed[][2] = {
+    {"eligius.st", "relay.eligius.st"},
     {"bitcoin.sipa.be", "seed.bitcoin.sipa.be"},
     {"bluematt.me", "dnsseed.bluematt.me"},
     {"dashjr.org", "dnsseed.bitcoin.dashjr.org"},
