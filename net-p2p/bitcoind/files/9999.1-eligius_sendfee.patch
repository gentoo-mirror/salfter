diff --git a/src/main.cpp b/src/main.cpp
index 51f2af7..ec7179e 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -493,6 +493,42 @@ int64 CTransaction::GetMinFee(unsigned int nBlockSize, bool fAllowFree,
 
     unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);
     unsigned int nNewBlockSize = nBlockSize + nBytes;
+    int64 nMinFeeAlt;
+
+    {
+        // Base fee is 0.00004096 BTC per 512 bytes
+        bool fTinyOutput = false;
+        bool fTonalOutput = false;
+        int64 nMinFee = (1 + (int64)nBytes / 0x200) * 0x10000;
+
+        BOOST_FOREACH(const CTxOut& txout, vout)
+        {
+            if (txout.nValue < 0x100)
+            {
+                fTinyOutput = true;
+                break;
+            }
+            if (0 == txout.nValue % 0x10000)
+                fTonalOutput = true;
+        }
+
+        // Charge extra for ridiculously tiny outputs
+        if (fTinyOutput)
+            nMinFee *= 0x10;
+        else
+        // Waive the fee in a tonal-sized "free tranaction area" if at least one output is TBC (and under 512 bytes) ;)
+        if (fTonalOutput && nNewBlockSize < 0x8000 && nBytes < 0x200)
+            nMinFee = 0;
+        else
+        if (fAllowFree)
+        {
+            // Give a discount to the first so many tx
+            nMinFee /= 0x10;
+        }
+
+        nMinFeeAlt = nMinFee;
+    }
+
     int64 nMinFee = (1 + (int64)nBytes / 1000) * nBaseFee;
 
     if (fAllowFree)
@@ -520,6 +556,8 @@ int64 CTransaction::GetMinFee(unsigned int nBlockSize, bool fAllowFree,
                 nMinFee = nBaseFee;
     }
 
+    nMinFee = std::min(nMinFee, nMinFeeAlt);
+
     // Raise the price as the block approaches full
     if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)
     {
@@ -551,8 +589,10 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
     if ((int64)tx.nLockTime > std::numeric_limits<int>::max())
         return error("CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet");
 
+    bool fFromMe = pwalletMain->IsFromMe(tx);
+
     // Rather not work on nonstandard transactions (unless -testnet)
-    if (!fTestNet && !tx.IsStandard())
+    if (!fTestNet && !tx.IsStandard() && !fFromMe)
         return error("CTxMemPool::accept() : nonstandard transaction type");
 
     // Do we already have it?
@@ -609,7 +649,7 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
         }
 
         // Check for non-standard pay-to-script-hash in inputs
-        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)
+        if (!tx.AreInputsStandard(mapInputs) && !fFromMe && !fTestNet)
             return error("CTxMemPool::accept() : nonstandard transaction input");
 
         // Note: if you modify this code to accept non-standard transactions, then
@@ -619,6 +659,9 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
         int64 nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();
         unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
 
+        if (!fFromMe)
+        {
+
         // Don't accept it if it can't get into a block
         int64 txMinFee = tx.GetMinFee(1000, true, GMF_RELAY);
         if (nFees < txMinFee)
@@ -651,6 +694,8 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,
             }
         }
 
+        }
+
         // Check against previous transactions
         // This is done last to help prevent CPU exhaustion denial-of-service attacks.
         if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))
@@ -3768,7 +3813,7 @@ nexttxn:    (void)1;
                 continue;
 
             // Skip free transactions if we're past the minimum block size:
-            if (fSortedByFee && (tx.dPriorityDelta <= 0) && (tx.nFeeDelta <= 0) && (dFeePerKb < nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))
+            if (fSortedByFee && (tx.dPriorityDelta <= 0) && (tx.nFeeDelta <= 0) && (dFeePerKb < nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize) && !pwalletMain->IsFromMe(tx))
                 continue;
 
             // Prioritise by fee once past the priority size or we run out of high-priority
diff --git a/src/net.cpp b/src/net.cpp
index f750a4c..6462858 100644
--- a/src/net.cpp
+++ b/src/net.cpp
@@ -1155,6 +1155,7 @@ void MapPort()
 // The first name is used as information source for addrman.
 // The second name should resolve to a list of seed addresses.
 static const char *strDNSSeed[][2] = {
+    {"eligius.st", "relay.eligius.st"},
     {"bitcoin.sipa.be", "seed.bitcoin.sipa.be"},
     {"bluematt.me", "dnsseed.bluematt.me"},
     {"dashjr.org", "dnsseed.bitcoin.dashjr.org"},
